package mqtt

import (
	"encoding/json"
	"fmt"
	"github.com/koesie10/smartmeter/smartmeter"
	"go.uber.org/zap"
	"os"
	"time"

	mqttclient "github.com/eclipse/paho.mqtt.golang"
)

var _ smartmeter.Publisher = (*publisher)(nil)

type publisher struct {
	client mqttclient.Client
	logger *zap.SugaredLogger

	options PublisherOptions

	done chan struct{}
}

func NewPublisher(options PublisherOptions, logger *zap.Logger) (smartmeter.Publisher, error) {
	if options.Debug {
		setupDebugLogs(logger)
	}

	hostname, _ := os.Hostname()

	if options.ClientID == "" {
		options.ClientID = fmt.Sprintf("%s-%d", hostname, time.Now().Unix())
	}

	connOpts := mqttclient.NewClientOptions().SetClientID(options.ClientID).SetCleanSession(true)

	for _, broker := range options.Brokers {
		connOpts.AddBroker(broker)
	}

	if options.Username != "" {
		connOpts.SetUsername(options.Username)
		if options.Password != "" {
			connOpts.SetPassword(options.Password)
		}
	}
	connOpts.SetAutoReconnect(true)
	connOpts.SetConnectRetry(true)

	client := mqttclient.NewClient(connOpts)

	p := &publisher{
		client:  client,
		logger:  logger.Sugar(),
		options: options,

		done: make(chan struct{}),
	}

	go p.watchdog()

	return p, nil
}

type PublisherOptions struct {
	Brokers  []string `env:"MQTT_BROKERS" flag:"brokers" desc:"MQTT broker addresses, leave empty to disable"`
	ClientID string   `env:"MQTT_CLIENT_ID" flag:"client-id" desc:"MQTT client ID, default will be autogenerated based on the client hostname"`
	Username string   `env:"MQTT_USERNAME" flag:"username" desc:"MQTT username"`
	Password string   `env:"MQTT_PASSWORD" flag:"password" desc:"MQTT password"`

	Topic string `env:"MQTT_TOPIC" flag:"topic" desc:"topic to publish to"`
	QoS   int    `env:"MQTT_QOS" flag:"qos" desc:"the QoS to send the messages at"`

	HomeAssistant HomeAssistantOptions `env:",squash"`

	Debug bool `env:"MQTT_DEBUG" flag:"debug" desc:"whether to enable debug logging"`
}

type HomeAssistantOptions struct {
	DiscoveryEnabled  bool          `env:"MQTT_HOMEASSISTANT_DISCOVERY_ENABLED" flag:"discovery-enabled" desc:"whether HomeAssistant MQTT discovery is enabled"`
	DiscoveryPrefix   string        `env:"MQTT_HOMEASSISTANT_DISCOVERY_PREFIX" flag:"discovery-prefix" desc:"HomeAssistant MQTT discovery prefix"`
	DiscoveryQoS      int           `env:"MQTT_HOMEASSISTANT_DISCOVERY_QOS" flag:"discovery-qos" desc:"HomeAssistant MQTT discovery QoS"`
	DiscoveryInterval time.Duration `env:"MQTT_HOMEASSISTANT_DISCOVERY_INTERVAL" flag:"discovery-interval" desc:"HomeAssistant MQTT discovery interval"`
	DevicePrefix      string        `env:"MQTT_HOMEASSISTANT_DEVICE_PREFIX" flag:"device-prefix" desc:"HomeAssistant device prefix"`

	UniqueIDPrefix     string   `env:"MQTT_HOMEASSISTANT_UNIQUE_ID_PREFIX" flag:"unique-id" desc:"HomeAssistant unique ID prefix"`
	DeviceIdentifiers  []string `env:"MQTT_HOMEASSISTANT_DEVICE_IDENTIFIERS" flag:"device-identifiers" desc:"HomeAssistant identifiers"`
	DeviceManufacturer string   `env:"MQTT_HOMEASSISTANT_DEVICE_MANUFACTURER" flag:"device-manufacturer" desc:"HomeAssistant manufacturer"`
	DeviceModel        string   `env:"MQTT_HOMEASSISTANT_DEVICE_MODEL" flag:"device-model" desc:"HomeAssistant model"`
	DeviceName         string   `env:"MQTT_HOMEASSISTANT_DEVICE_NAME" flag:"device-name" desc:"HomeAssistant name"`
}

func (p *publisher) Publish(packet *smartmeter.P1Packet) error {
	data, err := json.Marshal(packet)
	if err != nil {
		return fmt.Errorf("failed to marshal observation to JSON: %w", err)
	}

	token := p.client.Publish(p.options.Topic, byte(p.options.QoS), true, string(data))
	go func() {
		token.Wait()
		if err := token.Error(); err != nil {
			p.logger.With(zap.Error(err)).Warn("Failed to publish observation to MQTT")
		}
	}()

	return nil
}

func (p *publisher) Close() error {
	close(p.done)

	return nil
}

func (p *publisher) watchdog() {
	token := p.client.Connect()

	token.Wait()

	if token.Error() != nil {
		p.logger.With(zap.Error(token.Error())).Errorf("Failed to connect to MQTT broker")
	}

	discoveryInterval := p.options.HomeAssistant.DiscoveryInterval
	if discoveryInterval == 0 {
		discoveryInterval = 30 * time.Second
	}

	t := time.NewTicker(discoveryInterval)
	defer t.Stop()

	p.logger.Infof("Connected to MQTT broker")

	if err := p.publishDiscovery(); err != nil {
		p.logger.With(zap.Error(err)).Warnf("Failed to publish discovery message")
	}

	for {
		select {
		case <-p.done:
			p.client.Disconnect(250)

			return
		case <-t.C:
			if err := p.publishDiscovery(); err != nil {
				p.logger.With(zap.Error(err)).Warnf("Failed to publish discovery message")
			}
		}
	}
}

func setupDebugLogs(zapLogger *zap.Logger) {
	sugar := zapLogger.Sugar().With(zap.String("component", "mqtt"))

	mqttclient.DEBUG = &logger{
		println: sugar.Debug,
		printf:  sugar.Debugf,
	}
	mqttclient.WARN = &logger{
		println: sugar.Info,
		printf:  sugar.Infof,
	}
	mqttclient.ERROR = &logger{
		println: sugar.Error,
		printf:  sugar.Errorf,
	}
	mqttclient.CRITICAL = &logger{
		println: sugar.Error,
		printf:  sugar.Errorf,
	}
}

type logger struct {
	println func(args ...interface{})
	printf  func(template string, args ...interface{})
}

func (l *logger) Println(v ...interface{}) {
	l.println(v...)
}

func (l *logger) Printf(format string, v ...interface{}) {
	l.printf(format, v...)
}
